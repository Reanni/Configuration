# 锁的几种概念
|   名称   | 描述                                                                                                                                                         |                                                                       备注                                                                       |
|:-------:|:--------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------:|
|  同步锁  | 一个同步锁同一时刻只能被一个线程获取                                                                                                                            |                                                                                                                                                 |
|  独占锁  | 同同步锁、排他锁、悲观锁                                                                                                                                       |                                                                                                                                                 |
|  共享锁  | 一个共享锁同一时刻可以被多个线程同时获取                                                                                                                        |                                                                                                                                                 |
|  悲观锁  | 使用锁的时候总认为一定有其他线程来抢,一定要抢到锁才执行任务                                                                                                      |                                                                                                                                                  |
|  乐观锁  | 使用锁的时候总认为不会有其他线程来抢,先读数据执行任务,到写数据的时候查验读的数据有没有变化,如果没变化说明没被其他线程更改执行写入新数据操作,如果有变化重新读数据执行任务 |                                                                                                                                                 |
|  公平锁  | CLH队列锁 : 入队线程依次排队自旋,先到先得,公平的获取锁                                                                                                          |            上下文切换是一耗时操作,如果一把锁已有多个线程在排队,一个新线程再去抢这把锁需要将自身挂起并且唤醒前面线程,会增加多次上下文切换的消耗            |
| 非公平锁 | 无视先到先得的规则,可插队.入队线程先尝试获取锁,没有成功再开始自旋                                                                                                 |                                                 新线程直接插队抢锁,节约了上下文切换的资源,性能更佳                                                 |
| 可重入锁 | 同一把锁可多次被同一个线程获取                                                                                                                                 |                                                           对多次获取同一把锁进行计数统计                                                           |
| 非重入锁 | 同一把锁只能被同一个线程获取一次                                                                                                                                |                                               同一把锁没释放的情况下被某线程第二次获取就会把自己锁死                                                |
|  内置锁  | synchronized.jdk内部已经封装                                                                                                                                  |                               性能差:一旦开始获取锁就不能中断,当没获取到锁的时候就进行等待状态.没有提供尝试获取锁的机制                               |
|  显式锁  | Lock接口,有ReentrantLock、ReentrantReadWriteLock等实现类.                                                                                                     | 性能好:没获取锁时可以先执行其他流程.能够非阻塞的尝试获取锁机制、能被中断的地获取锁、超时获取锁.要在 try finally 里进行解锁,防止加锁代码异常导致锁无法释放 |

# 死锁与活锁
- 死锁
  - 概念 : 两个线程互相等待对方的资源,导致双方都无法继续进行
  - 危害 :
    1. 程序还活着,但线程不工作了
    2. 没有任务异常信息
    3. 一旦发生死锁,没任何办法恢复,只能重启程序
  - 死锁有四个条件 :
    1. 互斥条件(资源同一时间只能服务一个线程)
    2. 不可抢占条件(资源服务期间不可被其他线程抢占)
    3. 占有且申请条件(线程已占有资源并申请新资源)
    4. 循环等待条件
  - 死锁案例 : 有AB两人要用筷子夹菜,但只有一双筷子,各自抢到一根快子,互不相让
  - 解决方案 :
    1. 如非必要避免嵌套使用锁
    2. 保持加锁顺序一致
    3. 尝试拿锁机制(没拿到时释放已占有锁)

- 活锁
  - 概念 : 多个线程在尝试拿锁机制中,不断发生某线程拿到第一把锁,尝试拿其他锁失败面释放持有锁的过程
  - 危害 : 多个线程重复无用功,浪费性能
  - 解决方案 : 各线程在拿锁前休眠随机一段时间,错开拿锁时间

# 各种锁的特性

|          锁名          | 能否重入 |                     是否公平                     |    共享与独占     |
|:----------------------:|:-------:|:------------------------------------------------:|:----------------:|
|      synchronized      | 可重入锁 |                     非公平锁                     |      独占锁       |
|     ReentrantLock      | 可重入锁 | 构造传true为公平锁、false为非公平锁.默认为非公平锁 |      独占锁       |
| ReentrantReadWriteLock | 可重入锁 | 构造传true为公平锁、false为非公平锁.默认为非公平锁 | 读锁共享、写锁独占 |

# CLH队列锁
- 概念 : 一个需要获取锁的线程做为一个节点加入队伍,节点有两个属性`myPred`指向上一个入队节点,`locked:Boolean`设置为true表示需要获取锁、false表示释放了锁.申请线程会自旋轮询前驱状态,如果前驱释放了锁就结束自旋自身获取锁.

# AbstractQueuedSynchronizer
- AQS的概念 : 队列同步器,是用来构建锁或其他同步组件的基础框架.
- AQS使用了CLH的思想,但做了一些优化 : 单向链表改双向链表;自旋加入次数限制,达到限制后线程切换到阻塞状态
- AQS的使用方式及设计模式 : 使用模板方法设计模式,成员属性`state:Int`表示同步状态,在模块方法里通过`getState()`、`setState()`、`compareAndSetState()`3个方法对`state`处理来管理同步状态
- 方法介绍

    |            方法名            | 能否重写 |                描述                |                             备注                             |
    |:----------------------------:|:-------:|:----------------------------------:|:------------------------------------------------------------:|
    |          acquire()           |    ×    |         独占式获取同步状态          |       内部调用tryAcquire().如果获取失败进入同步队列等待        |
    |    acquireInterruptibly()    |    ×    |         独占式获取同步状态          |                        响应中断抛异常                         |
    |      tryAcquireNanos()       |    ×    |         独占式获取同步状态          |   响应中断的基础上增加超时限制.超时获取失败返回false,反之true   |
    |       acquireShared()        |    ×    |         共享式获取同步状态          |    内部调用tryAcquireShared().如果获取失败进入同步队列等待     |
    | acquireSharedInterruptibly() |    ×    |         共享式获取同步状态          |                        响应中断抛异常                         |
    |   tryAcquireSharedNanos()    |    ×    |         共享式获取同步状态          |   响应中断的基础上增加超时限制.超时获取失败返回false,反之true   |
    |          release()           |    ×    |        独占式的释放同步状态         |       内部调用tryRelease().释放后唤醒同步队列中第一个线程       |
    |       releaseShared()        |    ×    |        共享式的释放同步状态         |                  内部调用tryReleaseShared().                  |
    |      getQueuedThreads()      |    ×    |    获取等待在同步队列上的线程集合    |                                                              |
    |         tryAcquire()         |    √    |         独占式获取同步状态          | 实现该方法需要判断同步状态是否符合预期,然后再进行CAS设置同步状态 |
    |         tryRelease()         |    √    |        独占式的释放同步状态         |            等待获取同步状态的线程有机会获取同步状态             |
    |      tryAcquireShared()      |    √    |         共享式获取同步状态          |               返回值大于 0表示成功,反之表示失败                |
    |      tryReleaseShared()      |    √    |        共享式的释放同步状态         |                                                              |
    |     isHeldExclusively()      |    √    | 当前同步器是否在独占模式下被线程占用 |                  一般表示是否被当前线程所独占                  |

# Volatile特性
- 禁止重排序
- 保证可见性 : 对一个volatile变量的读,总是能看到任意线程对这个变量最后的写入的值
- 不一定保证原子性

    |                      场景                      | 是否具有原子性 |
    |:---------------------------------------------:|:-------------:|
    |                    一写多读                    |       √       |
    |                    多写多读                    |       ×       |
    | 写操作关联,需要用到上一次写操作的值,如 : i = i+1 |       ×       |
    |   写操作独立,与上一次写操作的值无关,如 : i = 5   |       √       |

- 实现原理 : 使用cpu提供的lock前缀指令,完成类似于内存屏障的功能.每次操作都会同步到主存,而且这个写操作会使用其他缓存失效
